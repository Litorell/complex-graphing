<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: expression-parser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: expression-parser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Main script of the complex graphing calculator.
 * 
 * @copyright Oscar Litorell 2019
 */

/**
 * Used for parsing infix expressions, and converting them to postfix.
 * @hideconstructor
 */
class ExpressionParser {
    /**
     * Check if a character is a number or decimal.
     * @param {string} char
     * @returns {boolean}
     */
    static isNumeral(char) {
        return "0123456789.".includes(char);
    }

    /**
     * Check if a character is a letter of the alphabet.
     * @param {string} char 
     * @return {boolean}
     */
    static isAlpha(char) {
        return (char.toLowerCase() !== char.toUpperCase());
    }

    /**
     * Get the type of a character, i.e. of it's a number, letter of the alphabet or something else.
     * @param {string} char 
     * @returns {string} "number", "alpha" or "other"
     */
    static getType(char) {
        if (ExpressionParser.isNumeral(char)) return "number";
        if (ExpressionParser.isAlpha(char)) return "alpha";
        return "other";
    }

    /**
     * Get the token at a given index in an expression.
     * @param {string} expression - The expression that should be parsed.
     * @param {*} index - The index where the token begins.
     * @returns {string} The complete token.
     */
    static parseToken(expression, index) {
        let char = expression[index];

        let oneChars = "+-*/^()";

        let type;

        if (oneChars.includes(char)) {
            return char;
        } else {
            type = ExpressionParser.getType(expression[index]);
        }


        for (var i = index + 1; i &lt; expression.length; i++) {
            if (ExpressionParser.getType(expression[i]) !== type) {

                // If last character is not i
                if (!(expression[i] === "i" &amp;&amp; (ExpressionParser.getType(expression[i - 1]) === type))) break;
            };
        }

        let token = expression.substring(index, i);

        return token;
    }


    /**
     * Check if a token is a function.
     * @param {string} token
     * @returns {boolean}
     */
    static isFunction(token) {
        return (token in operations &amp;&amp; operations[token].args === 1);
    }

    /**
     * Check if a token is an operator.
     * @param {string} token 
     */
    static isOperator(token) {
        return (token in operations &amp;&amp; operations[token].args === 2);
    }

    /**
     * Check if a token is a number
     * @param {string} token 
     */
    static isNumber(token) {
        return (token === "i" || ExpressionParser.isNumeral(token[0]));
    }



    /**
     * Parse an infix notation expression into a postfix expression. Logic is taken largely from wikipedia:
     * &lt;br>
     * &lt;a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm#The_algorithm_in_detail">https://en.wikipedia.org/wiki/Shunting-yard_algorithm#The_algorithm_in_detail&lt;/a>
     * @param {string} expression - The expression to parse written in infix notation.
     * @returns {string[]} The postfix expression stack.
     * @example
     * // returns ["2", "4", "3", "-", "*"]
     * ExpressionParser.parseExpression("2*(4-3)")
     */
    static parseExpression(expression) {
        let operators = {
            "^": {associativity: "right", precedence: 4},
            "*": {associativity: "left", precedence: 3},
            "/": {associativity: "left", precedence: 3},
            "+": {associativity: "left", precedence: 2},
            "-": {associativity: "left", precedence: 2}
        }

        expression = expression.replace(/\s/g, "").replace(/\(-/g, "(0-");
        if (expression[0] === "-") expression = "0" + expression;

        let operatorStack = [];
        let outputQueue = [];


        for (let i = 0; i &lt; expression.length;) {
            let token = ExpressionParser.parseToken(expression, i);

            i += token.length;       

            if (ExpressionParser.isFunction(token)) {
                operatorStack.push(token);
            } else if (ExpressionParser.isOperator(token)) {
                let top = operatorStack[operatorStack.length - 1];
                while (operatorStack.length > 0 &amp;&amp; (ExpressionParser.isFunction(top)
                    || (ExpressionParser.isOperator(top) &amp;&amp; operators[top].precedence > operators[token].precedence)
                    || (ExpressionParser.isOperator(top) &amp;&amp; operators[top].precedence === operators[token].precedence &amp;&amp; operators[top].associativity === "left"))
                    &amp;&amp; (top !== "(")) {
                    outputQueue.push(operatorStack.pop());
                    top = operatorStack[operatorStack.length - 1];
                }
                operatorStack.push(token);
            } else if (token === "(") {
                operatorStack.push(token);
            } else if (token === ")") {
                while (operatorStack.length > 0 &amp;&amp; operatorStack[operatorStack.length - 1] !== "(") {
                    outputQueue.push(operatorStack.pop())
                }
                if (operatorStack.length > 0 &amp;&amp; operatorStack[operatorStack.length - 1] === "(") {
                    operatorStack.pop();
                }
            } else {
                outputQueue.push(token);
            }

        }

        while (operatorStack.length > 0) {
            outputQueue.push(operatorStack.pop())
        }

        return outputQueue;
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Complex.html">Complex</a></li><li><a href="ExpressionParser.html">ExpressionParser</a></li><li><a href="LineStyle.html">LineStyle</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="Vector.html">Vector</a></li><li><a href="View.html">View</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addVariableElement">addVariableElement</a></li><li><a href="global.html#clickController">clickController</a></li><li><a href="global.html#deleteVariable">deleteVariable</a></li><li><a href="global.html#drawAxisLines">drawAxisLines</a></li><li><a href="global.html#drawCanvas3d">drawCanvas3d</a></li><li><a href="global.html#drawFunction">drawFunction</a></li><li><a href="global.html#drawLabel">drawLabel</a></li><li><a href="global.html#fullscreen">fullscreen</a></li><li><a href="global.html#isFullscreen">isFullscreen</a></li><li><a href="global.html#List">List</a></li><li><a href="global.html#moveGraph">moveGraph</a></li><li><a href="global.html#parseNumber">parseNumber</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#rotateGraph">rotateGraph</a></li><li><a href="global.html#setTracingPoint">setTracingPoint</a></li><li><a href="global.html#touchController">touchController</a></li><li><a href="global.html#updateCanvas">updateCanvas</a></li><li><a href="global.html#updateFunction">updateFunction</a></li><li><a href="global.html#updateFunctionValues">updateFunctionValues</a></li><li><a href="global.html#updateVariableList">updateVariableList</a></li><li><a href="global.html#updateVariableType">updateVariableType</a></li><li><a href="global.html#updateView">updateView</a></li><li><a href="global.html#userFunction">userFunction</a></li><li><a href="global.html#variableListToHTML">variableListToHTML</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Aug 25 2019 22:34:04 GMT+0200 (VÃ¤steuropa, sommartid)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
