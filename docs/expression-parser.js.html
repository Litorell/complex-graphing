<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>expression-parser.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ExpressionParser.html">ExpressionParser</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.getType">getType</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.isAlpha">isAlpha</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.isFunction">isFunction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.isNumber">isNumber</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.isNumeral">isNumeral</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.isOperator">isOperator</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.parseExpression">parseExpression</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ExpressionParser.html#.parseToken">parseToken</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">expression-parser.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Used for parsing infix expressions, and converting them to postfix.
 * 
 * @copyright Oscar Litorell 2019
 */

/**
 * Used for parsing infix expressions, and converting them to postfix.
 * @hideconstructor
 */
class ExpressionParser {
    /**
     * Check if a character is a number or decimal.
     * @param {string} char
     * @returns {boolean}
     */
    static isNumeral(char) {
        return "0123456789.".includes(char);
    }

    /**
     * Check if a character is a letter of the alphabet.
     * @param {string} char 
     * @returns {boolean}
     */
    static isAlpha(char) {
        return (char.toLowerCase() !== char.toUpperCase());
    }

    /**
     * Get the type of a character, i.e. of it's a number, letter of the alphabet or something else.
     * @param {string} char 
     * @returns {string} "number", "alpha" or "other"
     */
    static getType(char) {
        if (ExpressionParser.isNumeral(char)) return "number";
        if (ExpressionParser.isAlpha(char)) return "alpha";
        return "other";
    }

    /**
     * Get the token at a given index in an expression.
     * @param {string} expression - The expression that should be parsed.
     * @param {number} index - The index where the token begins.
     * @returns {string} The complete token.
     */
    static parseToken(expression, index) {
        let char = expression[index];

        let oneChars = "+-*/^()";

        let type;

        if (oneChars.includes(char)) {
            return char;
        } else {
            type = ExpressionParser.getType(expression[index]);
        }


        for (var i = index + 1; i &lt; expression.length; i++) {
            if (ExpressionParser.getType(expression[i]) !== type) {

                // If last character is not i
                if (!(expression[i] === "i" &amp;&amp; (ExpressionParser.getType(expression[i - 1]) === type))) break;
            };
        }

        let token = expression.substring(index, i);

        return token;
    }


    /**
     * Check if a token is a function.
     * @param {string} token
     * @returns {boolean}
     */
    static isFunction(token) {
        return (token in operations &amp;&amp; operations[token].args === 1);
    }

    /**
     * Check if a token is an operator.
     * @param {string} token 
     * @returns {boolean}
     */
    static isOperator(token) {
        return (token in operations &amp;&amp; operations[token].args === 2);
    }

    /**
     * Check if a token is a number
     * @param {string} token 
     * @returns {boolean}
     */
    static isNumber(token) {
        return (token === "i" || ExpressionParser.isNumeral(token[0]));
    }



    /**
     * Parse an infix notation expression into a postfix expression. Uses the shunting-yard algorithm:
     * &lt;br>
     * &lt;a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm#The_algorithm_in_detail">https://en.wikipedia.org/wiki/Shunting-yard_algorithm#The_algorithm_in_detail&lt;/a>
     * @param {string} expression - The expression to parse written in infix notation.
     * @returns {string[]} The postfix expression stack.
     * @example
     * // returns ["2", "4", "3", "-", "*"]
     * ExpressionParser.parseExpression("2*(4-3)")
     */
    static parseExpression(expression) {
        let operators = {
            "^": {associativity: "right", precedence: 4},
            "*": {associativity: "left", precedence: 3},
            "/": {associativity: "left", precedence: 3},
            "+": {associativity: "left", precedence: 2},
            "-": {associativity: "left", precedence: 2}
        }

        expression = expression.replace(/\s/g, "").replace(/\(-/g, "(0-");
        if (expression[0] === "-") expression = "0" + expression;

        let operatorStack = [];
        let outputQueue = [];


        for (let i = 0; i &lt; expression.length;) {
            let token = ExpressionParser.parseToken(expression, i);

            i += token.length;       

            if (ExpressionParser.isFunction(token)) {
                operatorStack.push(token);
            } else if (ExpressionParser.isOperator(token)) {
                let top = operatorStack[operatorStack.length - 1];
                while (operatorStack.length > 0 &amp;&amp; (ExpressionParser.isFunction(top)
                    || (ExpressionParser.isOperator(top) &amp;&amp; operators[top].precedence > operators[token].precedence)
                    || (ExpressionParser.isOperator(top) &amp;&amp; operators[top].precedence === operators[token].precedence &amp;&amp; operators[top].associativity === "left"))
                    &amp;&amp; (top !== "(")) {
                    outputQueue.push(operatorStack.pop());
                    top = operatorStack[operatorStack.length - 1];
                }
                operatorStack.push(token);
            } else if (token === "(") {
                operatorStack.push(token);
            } else if (token === ")") {
                while (operatorStack.length > 0 &amp;&amp; operatorStack[operatorStack.length - 1] !== "(") {
                    outputQueue.push(operatorStack.pop())
                }
                if (operatorStack.length > 0 &amp;&amp; operatorStack[operatorStack.length - 1] === "(") {
                    operatorStack.pop();
                }
            } else {
                outputQueue.push(token);
            }

        }

        while (operatorStack.length > 0) {
            outputQueue.push(operatorStack.pop())
        }

        return outputQueue;
    }
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed Apr 22 2020 20:30:40 GMT+0200 (GMT+02:00) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
